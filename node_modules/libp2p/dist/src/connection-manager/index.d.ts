import { SummaryObject } from './latency-monitor.js';
import type { AbortOptions } from '@libp2p/interfaces';
import { EventEmitter } from '@libp2p/interfaces/events';
import type { Startable } from '@libp2p/interfaces/startable';
import { PeerId } from '@libp2p/interface-peer-id';
import type { Connection, MultiaddrConnection } from '@libp2p/interface-connection';
import type { ConnectionManager, Dialer } from '@libp2p/interface-connection-manager';
import type { AddressSorter, PeerStore } from '@libp2p/interface-peer-store';
import { Resolver } from '@multiformats/multiaddr';
import type { Metrics } from '@libp2p/interface-metrics';
import type { Upgrader } from '@libp2p/interface-transport';
export interface ConnectionManagerInit {
    /**
     * The maximum number of connections to keep open
     */
    maxConnections: number;
    /**
     * The minimum number of connections to keep open
     */
    minConnections: number;
    /**
     * The max data (in and out), per average interval to allow
     */
    maxData?: number;
    /**
     * The max outgoing data, per average interval to allow
     */
    maxSentData?: number;
    /**
     * The max incoming data, per average interval to allow
     */
    maxReceivedData?: number;
    /**
     * The upper limit the event loop can take to run
     */
    maxEventLoopDelay?: number;
    /**
     * How often, in milliseconds, metrics and latency should be checked
     */
    pollInterval?: number;
    /**
     * How often, in milliseconds, to compute averages
     */
    movingAverageInterval?: number;
    /**
     * If true, try to connect to all discovered peers up to the connection manager limit
     */
    autoDial?: boolean;
    /**
     * How long to wait between attempting to keep our number of concurrent connections
     * above minConnections
     */
    autoDialInterval: number;
    /**
     * Sort the known addresses of a peer before trying to dial
     */
    addressSorter?: AddressSorter;
    /**
     * Number of max concurrent dials
     */
    maxParallelDials?: number;
    /**
     * Number of max addresses to dial for a given peer
     */
    maxAddrsToDial?: number;
    /**
     * How long a dial attempt is allowed to take, including DNS resolution
     * of the multiaddr, opening a socket and upgrading it to a Connection.
     */
    dialTimeout?: number;
    /**
     * When a new inbound connection is opened, the upgrade process (e.g. protect,
     * encrypt, multiplex etc) must complete within this number of ms.
     */
    inboundUpgradeTimeout: number;
    /**
     * Number of max concurrent dials per peer
     */
    maxDialsPerPeer?: number;
    /**
     * Multiaddr resolvers to use when dialing
     */
    resolvers?: Record<string, Resolver>;
    /**
     * On startup we try to dial any peer that has previously been
     * tagged with KEEP_ALIVE up to this timeout in ms. (default: 60000)
     */
    startupReconnectTimeout?: number;
    /**
     * A list of multiaddrs that will always be allowed (except if they are in the
     * deny list) to open connections to this node even if we've reached maxConnections
     */
    allow?: string[];
    /**
     * A list of multiaddrs that will never be allowed to open connections to
     * this node under any circumstances
     */
    deny?: string[];
    /**
     * If more than this many connections are opened per second by a single
     * host, reject subsequent connections
     */
    inboundConnectionThreshold?: number;
    /**
     * The maximum number of parallel incoming connections allowed that have yet to
     * complete the connection upgrade - e.g. choosing connection encryption, muxer, etc
     */
    maxIncomingPendingConnections?: number;
}
export interface ConnectionManagerEvents {
    'peer:connect': CustomEvent<PeerId>;
    'peer:disconnect': CustomEvent<PeerId>;
}
export interface DefaultConnectionManagerComponents {
    peerId: PeerId;
    metrics?: Metrics;
    upgrader: Upgrader;
    peerStore: PeerStore;
    dialer: Dialer;
}
/**
 * Responsible for managing known connections.
 */
export declare class DefaultConnectionManager extends EventEmitter<ConnectionManagerEvents> implements ConnectionManager, Startable {
    private readonly components;
    private readonly opts;
    private readonly connections;
    private started;
    private timer?;
    private readonly latencyMonitor;
    private readonly startupReconnectTimeout;
    private connectOnStartupController?;
    private readonly dialTimeout;
    private readonly allow;
    private readonly deny;
    private readonly inboundConnectionRateLimiter;
    private incomingPendingConnections;
    constructor(components: DefaultConnectionManagerComponents, init: ConnectionManagerInit);
    isStarted(): boolean;
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    start(): Promise<void>;
    afterStart(): Promise<void>;
    beforeStop(): Promise<void>;
    /**
     * Stops the Connection Manager
     */
    stop(): Promise<void>;
    /**
     * Cleans up the connections
     */
    _close(): Promise<void>;
    /**
     * Checks the libp2p metrics to determine if any values have exceeded
     * the configured maximums.
     *
     * @private
     */
    _checkMetrics(): Promise<void>;
    onConnect(evt: CustomEvent<Connection>): void;
    /**
     * Tracks the incoming connection and check the connection limit
     */
    _onConnect(evt: CustomEvent<Connection>): Promise<void>;
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt: CustomEvent<Connection>): void;
    getConnections(peerId?: PeerId): Connection[];
    openConnection(peerId: PeerId, options?: AbortOptions): Promise<Connection>;
    closeConnections(peerId: PeerId): Promise<void>;
    /**
     * Get all open connections with a peer
     */
    getAll(peerId: PeerId): Connection[];
    /**
     * If the event loop is slow, maybe close a connection
     */
    _onLatencyMeasure(evt: CustomEvent<SummaryObject>): void;
    /**
     * If the `value` of `name` has exceeded its limit, maybe close a connection
     */
    _checkMaxLimit(name: keyof ConnectionManagerInit, value: number, toPrune?: number): Promise<void>;
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    _pruneConnections(toPrune: number): Promise<void>;
    acceptIncomingConnection(maConn: MultiaddrConnection): Promise<boolean>;
    afterUpgradeInbound(): void;
}
//# sourceMappingURL=index.d.ts.map